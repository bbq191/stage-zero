1. 服务端 server

	1. 异步任务 

		- [x] 接收外部进来的 TCP 连接
		- [x] 并发处理多条连接的请求
		- [x] 使用 hashmap 来存储 redis 的数据

	2. 共享状态

		- [x] 状态(数据)无法在多个连接之间共享

		1. 共享之后出现的问题-任务、线程和锁竞争

		> 当竞争不多的时候，使用阻塞性的锁去保护共享数据是一个正确的选择。当一个锁竞争触发后，当前正在执行任务(请求锁)的线程会被阻塞，并等待锁被前一个使用者释放。这里的关键就是：**锁竞争不仅仅会导致当前的任务被阻塞，还会导致执行任务的线程被阻塞，因此该线程准备执行的其它任务也会因此被阻塞！**

		- [ ] 创建专有任务并使用消息传递的方式来管理状态
		- [ ] 将锁进行分片
		- [ ] 重构代码以避免锁

   3. 服务关闭而不是 CTRL - C （最后考虑）



2. 客户端 client

	1. 消息传递

		- [ ] 类型
		- [ ] 通道
		- [ ] 任务
		- [ ] 消息限制
		- [ ] 通道限制

	3. I/O

		- [ ] 回声服务 Echo

		> 实现 web 服务器，往往会选择实现一个回声服务。该服务会将用户的输入内容直接返回给用户，就像回声壁一样。
		> 
		> 具体来说，就是从用户建立的 TCP 连接的 socket 中读取到数据，然后立刻将同样的数据写回到该 socket 中。因此客户端会收到和自己发送的数据一模一样的回复。

		- [ ] 读写分离器
		- [ ] 堆缓冲区
		- [ ] 处理 EOF

	3. 解析数据帧

		- [ ] 缓冲读
		- [ ] 帧解析
		- [ ] 缓冲写

	4. 数据的 select

		> 在实际使用时，一个重要的场景就是同时等待多个异步操作的结果，并且对其结果进行进一步处理

	5. 迭代器

		- [ ] redis 广播

		1. 两种适配器

			- [ ] 迭代器适配器 - 会将一个迭代器转变成另一个迭代器
			- [ ] 消费者适配器 - 会消费掉一个迭代器，最终生成一个值



3. 异步与同步的共存
